### 第三周
##### 正则表达式

正则表达式:由一类特殊字符及文本字符所编写的模式,其中有些字符(元字符)不表示字符字面意义,而表示控制或通配的功能
分两类:

  1.基本正则表达式:BRE

2.扩展正则表达式:ERE


                grep -E,  egrep
元字符分类:字符匹配.匹配次数.位置锚定.分组

man帮助写法 man    7 regex


##### 基本正则表达式元字符

###### 字符匹配:

. 匹配任意单个字符
(注意写到[ ]里面就表示 . 不代表其他任何含义)

[]   匹配指定范围内的任意单个字符，
示例：[wang]  [0-9]    [a-z]   [a-zA-Z]  
是上述其中包含的任意组字符  
不包含123的写法:(包含不是123的其他字符)(有123的也还显示)

```
grep "[^123]"
```


有123的行直接不显示的写法

```
grep -v "[^123]"
```

> [^]  匹配指定范围外的任意单个字符(注意一定要在[ ] 里面 )  
> ^mage 是锚定行首 以马哥开头的
> wang$ 是锚定行尾 以wang结束的
[:alnum:] 字母和数字  
[:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z  
[:lower:] 小写字母  
[:upper:] 大写字母  
[:blank:]空白字符（空格和制表符）
[:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广）  
[:cntrl:] 不可打印的控制字符（退格、删除、警铃...）  
[:digit:] 十进制数字   
[:xdigit:]十六进制数字  
[:graph:] 可打印的非空白字符  
[:print:] 可打印字符
[:punct:] 标点符号

##### 匹配次数：
用在要指定次数的字符后面，用于指定前面的字符要出现的次数

     * 匹配前面的字符任意次，包括0次(例如a*  表示a出现的字符不确定包括0)
                贪婪模式：尽可能长的匹配(出现次数不确定)
                懒惰模式:一旦匹配到就不会向下继续匹配
> .* 任意长度的任意字符
> 
>   \\? 匹配其前面的字符0或1次(简单来说是看有或者没有这个字符)  
>   \\+ 匹配其前面的字符至少1次  
> \\{n\\} 匹配前面的字符n次(n代表数字,输入多少就只显示多少个字符)\ \   
> \\{m,n\\}匹配前面的字符至少m次，至多n次  
> \\{,n\\}匹配前面的字符至多n次  
> \\{n,\\} 匹配前面的字符至少n次
> 
> 
> 个位数到百位数表示方式:"[0-9]\{1,3\}"   (个位数   百位数)
> 默认是贪婪模式   grep -o 则只到百位
> 
> grep "o\{2\}"  找出至少有 2个o的行   只要包含2o就会出现 没有上限
> 
> \\. 转意 将原本表示单个任意字符的.转意成为单纯的.

##### 位置锚定：定位出现的位置
> ^ 行首锚定，用于模式的最左侧(一定要放在[ ]的外面)
> 
> $ 行尾锚定，用于模式的最右侧
> 
> ^PATTERN$   用于模式匹配整行
> 
> ^$  空行
> 
> 
>  ^[[:space:]］ 空白行
> 
> \< 或 \b 词首锚定，用于单词模式的左侧
> 
> \> 或 \b 词尾锚定，用于单词模式的右侧
> 
> \<PATTERN\> 匹配整个单词
> 
> 数字,下划线_ 字母不能作为单词分隔符

##### grep的变量 用法
> -a 不要忽略二进制数据。
> 
> -A<显示列数> 除了显示符合范本样式的那一行之外，并显示该行之后的内容。
> 
> -b 在显示符合范本样式的那一行之外，并显示该行之前的内容。
> 
> -c 计算符合范本样式的列数。
> 
> -C<显示列数>或-<显示列数> 
> 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。
> 
> -d<进行动作> 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。
> 
> -e<范本样式> 指定字符串作为查找文件内容的范本样式。
> 
> -E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。
> 
> -f<范本文件> 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。
> 
> -F 将范本样式视为固定字符串的列表。
> 
> -G 将范本样式视为普通的表示法来使用。
> 
> -h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。
> 
> -H 在显示符合范本样式的那一列之前，标示该列的文件名称。
> 
> -i 忽略字符大小写的差别。
> 
> -l 列出文件内容符合指定的范本样式的文件名称。
> 
> -L 列出文件内容不符合指定的范本样式的文件名称。
> 
> -n 在显示符合范本样式的那一列之前，标示出该列的编号。
> 
> -q 不显示任何信息。
> 
> -R/-r 此参数的效果和指定“-d recurse”参数相同。
> 
> -s 不显示错误信息。
> 
> -v 反转查找。
> 
> -w 只显示全字符合的列。
> 
> -x 只显示全列符合的列。
> 
> -y 此参数效果跟“-i”相同。
> 
> -o 只输出文件中匹配到的部分。

```

查看IP地址:
ifconfig ens33 | grep -o "[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}"  | head -n1

```


### shell脚本编程脚本
编程逻辑处理方式

	1. 顺序执行

	2. 循环执行
	
	3. 选择执行


shell编程: 过程式,解释执行

   编程语言的基本结构
   
	1. 各种系统命令的组合
	2. 数据存储:变量,数组
	3. 语句
	4. 表达式

shell脚本:

  包含一些命令或声明,并符合一定格式的文本文件
  
格式要求: 首行shebang机制

	1. #!/bin/bash
	2. #!/usr/bin/Python
	3. #!/usr/bin/perl


运行脚本:给予执行权限

	chmod +x  脚本

bash hello.sh可以不用给予权限直接执行hello.sh的脚本

脚本调试:

检测脚本语法:bash -n hello.sh

跟踪脚本执行:bash -x hello.sh

变量:
变量命名法则

	1. 不能使用程序中的变量如:if , echo等
	2. 只能使用数字,字母,下划线 注:不能以数字开头
	3. 见名知意
	4. 驼峰法   注: 是单词首字母大写
变量引用要用$

删除变量:unset

普通变量:只针对当前进程有效  
父进程的变量在子进程中不能使用


##### 环境变量(export):  
> 变量声明,赋值:(让子进程可以使用父进程中的变量)  
> export name=VALUE(变量)     
> declare -x name=VALUE(变量)
> 
> echo  $SHLVL   查看shell的嵌套深度 . 开了几个子进程
> 
> ( ) 里面的命令变量 会开启一个子进程 不会影响( )外面的变量
> 
> 查看当前进程的编号 :
> 
> echo $$
> 
> echo $BASHPID  
> 此命令显示的更加精准
> 当前进程的上级进程的编号    echo $PPID
> 示例 编写一个脚本  

```
RED="\033[1;31m"
echo -e "OS version is $RED`cat /etc/centos-release`\033[0m"
echo -e "kernel version $RED`uname -r`\033[0m"
echo -e "The cpu type is $RED`lscpu |egrep -i 'model name' |tr -s ' ' |cut -d: -f2`\033[0m"
echo -e "The memory is $RED`free -h|egrep Mem |tr -s ' ' ':' |cut -d: -f2`\033[0m"
echo -e "The max disk used is $RED`df |grep /dev/sd|tr -s " " ":"|cut -d: -f5|sort -nr|head -1`\033[0m"                                                                                        
echo -e "The hostname is $RED$(hostname)\033[0m"
echo -e "The ipaddr is $RED` ifconfig|head -2|tail -1|tr -s " " ":"|cut -d: -f3`\033[0m"

```
##### 环境变量(export):
> 变量声明,赋值:(让子进程可以使用父进程中的变量)  
> export name=VALUE(变量)  
> declare -x name=VALUE(变量)
> 
> echo  $SHLVL 查看shell的嵌套深度 . 开了几个子进程  
> ( ) 里面的命令变量 会开启一个子进程 不会影响( )外面的变量
> 
> 查看当前进程的编号 :
> 
> echo $$  
> echo $BASHPID   此命令显示的更加精准当前进程的上级进程的编号    echo $PPID
> 
> /etc/proffile.d/   配置文件放到这里则全局生效  (配置文件生效)  
> /etc/proffile.d/ 此文件内放的配置文件是全局生效的  
> 单个用户生效 写在此用户的家目录里面

##### 只读变量:
> 只能声明,但不能修改删除
> 自己可以设置只读变量:
> 
> readonly  文件名=文件内容
> 
> 或把其他变量设置成只读变量:
> readonly  文件名
> 
> 查看只读文件都有哪些:
> 
> 	1. declare -r
> 	2. readonly -p
> 

##### 位置变量:
ip.sh a b c   
$1=a $2=b ......  
$1 系统会自动的将第一个变量赋予给$!1  

注意!  $10的设置方法  

```
举例:   echo "1st arg is $1"
        echo "2st arg is $2"
        echo "3st arg is $3"
        echo  "10st arg is ${10}"
```

注意一定要将10扩起来否则会被识别成$1  加 0 

$0 表示脚本本身和路径  
如果想要只显示脚本名称需要输入 
```

`basename $0`

```

$* 和$@表示所有参数  
all arg are $*
$#  表示有几个参数  
set -- 清除所有位置变量  清除所有位置参数

$@: 在脚本1里面设置的参数能传给脚本2
如在脚本test1里面输入 

```
        echo "all arg is $*"
        test2.sh "$@"
```

脚本test2 里面输入 
     
```
echo 1st arg is $1
```

执行: 
 
```
  test1.sh a b c
  all arg is a b c
  1st arg is a
```
如果是$* 会将所有的参数视作一个整体

整理$*和$@的区别:

> $* : 在脚本1里面调用脚本2的参数时 全部参数合并成一个字符串(合并成了一个参数)

> $@ :在脚本1里面调用脚本2的参数时 参数会正确分配

> 用命令表示:

> $*等同于 test2.sh "a b c"

> $@等同于 test2.sh "a" "b" "c"

注意:在脚本里默认不支持别名

curl http://   是基于命令行的浏览器

##### 逻辑运算
1 代表真 true

0代表假  false
##### 与的关系:
	1与1=1
    1与0=0
	0与1=0
    0与0=0

##### 或的关系:
	1或1=1
	1或0=1
	0或1=1
	0或0=0

##### 短路与 &&

> 如果cmd1为真则执行cmd2(因为短路与需要两个都是真)
> 
> cmd & & cmd
> 
> 如果cmd1为假则不执行cmd2

##### 短路或| |
> cmd1短路或| | cmd2 
> 
> cmd1为真则不执行cmd2
> 
> cmd1为假则执行cmd2
> 
> 
> cmd 1 &&cmd2 | | cmd3
> 
> cmd 1 | |cmd2 && cmd3
